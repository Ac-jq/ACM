# 什么是拓扑序列
拓扑序列是对于有向图而言的，有向图的拓扑序是其顶点的线性排序，使得对于从顶点u到顶点v的每个有向边$u -> v$, u在序列中都在$v$之前。

例如对于下图：![!\[Alt text\](%E6%8B%93%E6%89%91%E5%BA%8F.png)](../../../_resources/%E6%8B%93%E6%89%91%E5%BA%8F.png)

对于上图， 存在4条边：$（1,3）（1,2）（2,4）（2,3）$
该图的拓扑序必须要满足以下两点：

1. 每个顶点只出现一次。
2. 对于图中的任何一条边，起点必须在终点之前。
## 拓扑序的求法
- 首先，不是所有的有向图都是有拓扑序的，只有有向无环图才有拓扑序，所以有向无环图又被称为拓扑图。
- 拓扑序是按照点的先后顺序排列的，也就是说入度为0的点一定是排在前面的，我们直接对一个图BFS一遍，BFS过程中更新每个点的入度，如果一个点的入度为0，那么就将其加入拓扑序，并且删除其与后继结点的所有边。
- 在读入边的时候，直接计算点的入度。

## 核心操作
- 注意：根据情况分析具体抽象题意，可能需要[建立虚拟节点--笛卡尔乘积](https://www.acwing.com/problem/content/458/)
### 建图
```
memset (h,-1,sizeof (h));
    cin >> n;
    for (int i = 1;i <= n;i++) {
        int x;
        while (cin >> x,x) {
            add (i,x);
            in_deg[x]++;
        }
    }  
```

### 
拓扑排序（$q[]$的下标默认从0开始，可调整）
```
void top_sort () {
    tt = -1;
    for (int i = 1;i <= n;i++) {
        if (!in_deg[i]) q[++tt] = i;
    }
    while (hh <= tt) {
        int t = q[hh++];
        for (int i = h[t];~i;i = ne[i]) {
            int j = e[i];
            in_deg[j]--;
            if (!in_deg[j]) q[++tt] = j;
        }
    }
}
```
