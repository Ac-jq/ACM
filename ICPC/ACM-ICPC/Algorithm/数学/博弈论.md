# 博弈论
# 公平组合游戏ICG
若一个游戏满足
1. 由两名玩家交替行动
2. 在游戏进程的任意时刻，可以执行的合法行动与轮到哪名玩家无关
3. 不能行动的玩家判负
则成该游戏为一个公平组合游戏

尼姆游戏（NIM）属于公平组合游戏，但常见的棋类游戏，比如围棋就不是公平组合游戏，因为围棋交战双方分别只能落黑子和白子，胜负判定也比较负责，不满足条件2和3。

## 一、Nim游戏
给定 n堆石子，两位玩家轮流操作，每次操作可以从任意一堆石子中拿走任意数量的石子（可以拿完，但不能不拿），最后无法进行操作的人视为失败。

问如果两人都采用最优策略，先手是否必胜。

### 结论
$假设n堆石子，石子数目分别是a1,a2,…,an，如果a1⊕a2⊕…⊕an≠0，先手必胜；否则先手必败。$
### 证明
证明：不妨设x的二进制表示中最高一位1在第k位，那么在$a1,a2,…,an中，必然有一个数ai，它的第k位是1，且ai⊕x < ai，那么从第i堆石子中拿走(ai−ai⊕x)个石子，第i堆石子还剩ai−(ai−ai⊕x)=ai⊕x，此时a1⊕a2⊕…⊕ai⊕x⊕…⊕an=x⊕x=0$

- 操作到最后时，每堆石子数都是0，0 ⊕ 0 ⊕ … 0 = 0
- 在操作过程中，如果 a1 ⊕ a2 ⊕ … ⊕ an = x ≠ 0。那么玩家必然可以通过拿走某一堆若干个石子将异或结果变为0。

```
#include <iostream>
#include <cstdio>
using namespace std;

int main(){
    int n;
    scanf("%d", &n);
    int res = 0;
    for(int i = 0; i < n; i++) {
        int x;
        scanf("%d", &x);
        res ^= x;
    }
    if(res == 0) puts("No");
    else puts("Yes");
}
```
## 二、台阶-Nim游戏
有一个 n级台阶的楼梯，每级台阶上都有若干个石子，其中第 i级台阶上有 ai个石子(i≥1)。

两位玩家轮流操作，每次操作可以从任意一级台阶上拿若干个石子放到下一级台阶中（不能不拿）。

已经拿到地面上的石子不能再拿，最后无法进行操作的人视为失败。

问如果两人都采用最优策略，先手是否必胜。

### 分析：此时我们需要将奇数台阶看做一个经典的Nim游戏，如果先手时奇数台阶上的值的异或值为0，则先手必败，反之必胜
因此无论后手如何移动，先手总能通过操作把奇数异或为0的情况留给后手，当奇数台阶全为0时，只留下偶数台阶上有石子。
（核心就是：先手总是把奇数台阶异或为0的状态留给对面，即总是将必败态交给对面）

因为偶数台阶上的石子要想移动到地面，必然需要经过偶数次移动，又因为奇数台阶全0的情况是留给后手的，因此先手总是可以将石子移动到地面，当将最后一个（堆）石子移动到地面时，后手无法操作，即后手失败。
```
#include <iostream>

using namespace std;

int main() {
    int res = 0;
    int n;
    cin >> n;

    for(int i = 1 ; i <= n ; i++) {
        int x;

        cin >> x;
        if(i % 2) res ^= x;
    }

    if(res) puts("Yes");
    else puts("No");
    return 0;
}
```
# SG函数
给定 n
 堆石子以及一个由 k
 个不同正整数构成的数字集合 S
。

现在有两位玩家轮流操作，每次操作可以从任意一堆石子中拿取石子，每次拿取的石子数量必须包含于集合 S
，最后无法进行操作的人视为失败。

问如果两人都采用最优策略，先手是否必胜。
![Alt text](../../../_resources/SG%E5%87%BD%E6%95%B0.jpg)

```
#include<iostream>
#include<cstring>
#include<algorithm>
#include<set>

using namespace std;

const int N=110,M=10010;
int n,m;
int f[M],s[N];//s存储的是可供选择的集合,f存储的是所有可能出现过的情况的sg值

int sg(int x) {
    if(f[x] != -1) return f[x];
    //因为取石子数目的集合是已经确定了的,所以每个数的sg值也都是确定的,如果存储过了,直接返回即可
    set<int> S;
    //set代表的是有序集合(注:因为在函数内部定义,所以下一次递归中的S不与本次相同)
    for(int i = 0; i < m; i ++ ) {
        int sum = s[i];
        if(x >= sum) S.insert(sg(x - sum));
        //先延伸到终点的sg值后,再从后往前排查出所有数的sg值
    }

    for(int i = 0; ; i ++ )
    //循环完之后可以进行选出最小的没有出现的自然数的操作
        if(!S.count(i))
            return f[x]=i;
}

int main()
{
    cin >> m;
    for(int i = 0; i < m; i ++ )
    cin >> s[i];

    cin >> n;
    memset(f, -1, sizeof f);//初始化f均为-1,方便在sg函数中查看x是否被记录过

    int res = 0;
    for(int i = 0; i < n; i ++ ) {
        int x;
        cin >> x;
        res ^= sg(x);
        //观察异或值的变化,基本原理与Nim游戏相同
    }

    if(res) printf("Yes");
    else printf("No");

    return 0;
}
```
## 补充
1. Mex运算:
设S表示一个非负整数集合.定义mex(S)为求出不属于集合S的最小非负整数运算,即:
mes(S)=min{x};
例如:S={0,1,2,4},那么mes(S)=3;

2. SG函数
在有向图游戏中,对于每个节点x,设从x出发共有k条有向边,分别到达节点y1,y2,····yk,定义SG(x)的后记节点y1,y2,····
yk的SG函数值构成的集合在执行mex运算的结果,即:
SG(x)=mex({SG(y1),SG(y2)····SG(yk)})
特别地,整个有向图游戏G的SG函数值被定义为有向图游戏起点s的SG函数值,即 SG(G)=SG(s).

3. 有向图游戏的和
设G1，G2,····,Gm是m个有向图游戏.定义有向图游戏G,他的行动规则是任选某个有向图游戏Gi,并在Gi上行动一步.G被称为有向图游戏G1,G2,·····,Gm的和.
有向图游戏的和的SG函数值等于它包含的各个子游戏SG函数的异或和,即:
SG(G)=SG(G1)xorSG(G2)xor···xor SG(Gm)












# SG函数