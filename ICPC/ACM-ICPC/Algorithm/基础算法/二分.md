# $二分$
## 1. 整数二分
```
void solve(int l, int r) {
    while (l < r) {
        //往左找 int mid= l + r >> 1;
        //往右找
        int mid = l + r + 1 >> 1;
        if (check(mid)) {
            //往左找 r = mid;
            //往右找
            l = mid;

        } else {
            //往左找 l = mid + 1;
            //往右找
            r = mid - 1;
        }
    }
}
```

## 2. 浮点数二分
```
//区别
while (fabs(r - l) > eps) {//eps一般比要求保留的位数再精确两位
    int mid = (l + r) / 2;
}
```
<br>
<br>
<br>

# 3. $二分答案 !$
- ## [NOIP2015 提高组] 跳石头

### 题目描述

这项比赛将在一条笔直的河道中进行，河道中分布着一些巨大岩石。组委会已经选择好了两块岩石作为比赛起点和终点。在起点和终点之间，有 $N$ 块岩石（不含起点和终点的岩石）。在比赛过程中，选手们将从起点出发，每一步跳向相邻的岩石，直至到达终点。

为了提高比赛难度，组委会计划移走一些岩石，使得选手们在比赛过程中的最短跳跃距离尽可能长。由于预算限制，组委会至多从起点和终点之间移走 $M$ 块岩石（不能移走起点和终点的岩石）。

### 输入格式

第一行包含三个整数 $L,N,M$，分别表示起点到终点的距离，起点和终点之间的岩石数，以及组委会至多移走的岩石数。保证 $L \geq 1$ 且 $N \geq M \geq 0$。

接下来 $N$ 行，每行一个整数，第 $i$ 行的整数 $D_i( 0 < D_i < L)$， 表示第 $i$ 块岩石与起点的距离。这些岩石按与起点距离从小到大的顺序给出，且不会有两个岩石出现在同一个位置。

### 输出格式

一个整数，即最短跳跃距离的最大值。
```
#include <iostream>
#include <algorithm>
#include <cstring>
using namespace std;
//最短跳跃距离的最大值意思：能移走最多m块石头所能制造的最小距离的最大值 
const int N = 50010;
//能不能移走最多m块石头让每块石头距离不小于d
int n, m, l;
int a[N], c[N];

int check(int d) {
	int cnt = 0, stand = 0;//需要移走cnt块石头，脚下在stand位置
	for (int i = 1; i <= n + 1; i ++ ) {
		if (a[i] - stand < d) {
			cnt ++ ;
		} else {
			stand = a[i];
		}
	}
	return cnt <= m;
}

int main() {
	cin >> l >> n >> m;
	for (int i = 1; i <= n; i ++ ) {
		scanf("%d", &a[i]);
	}
	
	a[n + 1] = l;
	int ll = 1, rr = l;
	while (ll < rr) {//找所有满足条件的最小值,再小就跳不过去了 
		int mid = ll + rr + 1 >> 1;
		if (check(mid)) {//若此条件可以，就再把条件严格一点
			ll = mid;
		} else {
			rr = mid - 1;
		}
	}
	cout << ll;
	return 0;
	
}
```

## [TJOI2007] 路标设置

### 题目背景

B 市和 T 市之间有一条长长的高速公路，这条公路的某些地方设有路标，但是大家都感觉路标设得太少了，相邻两个路标之间往往隔着相当长的一段距离。为了便于研究这个问题，我们把公路上相邻路标的最大距离定义为该公路的“空旷指数”。

### 题目描述

现在政府决定在公路上增设一些路标，使得公路的“空旷指数”最小。他们请求你设计一个程序计算能达到的最小值是多少。请注意，公路的起点和终点保证已设有路标，公路的长度为整数，并且原有路标和新设路标都必须距起点整数个单位距离。

### 输入格式

第 $1$ 行包括三个数 $L,N,K$，分别表示公路的长度，原有路标的数量，以及最多可增设的路标数量。


第 $2$ 行包括递增排列的 $N$ 个整数，分别表示原有的 $N$ 个路标的位置。路标的位置用距起点的距离表示，且一定位于区间 $[0,L]$ 内。

### 输出格式

输出 $1$ 行，包含一个整数，表示增设路标后能达到的最小“空旷指数”值。


### 提示

公路原来只在起点和终点处有两个路标，现在允许新增一个路标，应该把新路标设在距起点 $50$ 或 $51$ 个单位距离处，这样能达到最小的空旷指数 $51$。

```
#include <iostream>
using namespace std;

const int N = 100050;
int l, n, k;
int a[N];

int check(int d) {
	int cnt = 0, stand = 0;
	for (int i = 1; i <= n; i ++ ) {
		while (a[i] - stand > d) {//路标距离脚下大于d
			cnt ++ ;//插一个标
			stand += d;//走到那个标的位置
		}
		stand = a[i];
	}
	return cnt <= k;//插的标数量不超k则满足，接下来就再严格一点（d大一点）
}

int main() {
	cin >> l >> n >> k;
	for (int i = 1; i <= n; i ++ ) {
		scanf("%d", &a[i]);
	}
	
	int ll = 1, rr = l;
	while (ll < rr) {
		int mid = ll + rr >> 1;
		if (check(mid)) {
			rr = mid;
		} else {
			ll = mid + 1;
		}
	}
	cout << ll << endl;
	return 0;
}
```


